/* strindex: return index of t in s, -1 if none */
int strindex(const char s[], const char t[])
{
	int i, j, k;

	for (i = 0; s[i] != '\0'; ++i) {
		/* 下面的for循环的判断条件s[j]==t[k]比判断条件s[j]!=t[k]要好很多.
		 * 该函数是要查找字符串t在字符串s中是否有匹配,则直接判断两个字符是
		 * 否相等,更符合语义;s[j]!=t[k]在不匹配时执行循环体,查找时往往不匹
		 * 配的多,因此循环体的执行次数就多,而s[j]==t[k]在匹配时执行循环体,
		 * 若t有n个字符,则一共只需要执行n次循环体,运行效率比s[j]!=t[k]要好.
		 * 下面的for循环如果省去变量j,写成如下的形式:
		 * for (k = 0; t[k] != '\0' && s[i] == t[k]; ++i, ++k)
		 *     ;
		 * 则会出错.例如,s="coould",t="ould",当i==1,k==0时,s[i]==t[0],则++i
		 * ++k之后,变为s[2]!=t[1],跳出循环,返回上层的for循环,再++i,则s[i]==
		 * s[3]='u';再执行内层for循环,可见t[k]==t[0]!=s[3],跳出循环,此后再
		 * 也不相等,即不匹配.但是t在s中是能匹配的.所以上面的循环有错.
		 */
		for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; ++j, ++k)
			;
		if (k > 0 && t[k] == '\0') /* 保证 t 不是空字符串"" */
			return i;
	}
	return -1;
}
